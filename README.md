![Typescript](https://res.cloudinary.com/suberiq/image/upload/v1683830585/MASTER_TYPESCRIPT_2_-min_rhvi4x.png)


# ðŸ‡®ðŸ‡³ Error Handling

<details>    
  <summary>1. Syntax Errors </summary>
  
        ðŸ‘‰ Description: Errors that occur due to invalid syntax.

        let x = 10 // Missing semicolon
        console.log(x)

 </details> 
<details>    
  <summary>2. Type Errors </summary>
  
        ðŸ‘‰ Description: Occur when values are assigned or used in ways that are inconsistent with their types.

        let num: number = "hello"; // Error: Type 'string' is not assignable to type 'number'.

 </details> 
<details>    
  <summary>3. Reference Errors </summary>
  
       ðŸ‘‰ Description: Occur when referencing variables or functions that don't exist.

       console.log(y); // Error: Cannot find name 'y'.

 </details> 
<details>    
  <summary>4. Range Errors </summary>
  
       ðŸ‘‰ Description: Occur when a value is outside the allowable range.

       let arr = new Array(-1); // Error: Invalid array length

 </details> 
<details>    
  <summary>5. Logic Errors</summary>
  
       ðŸ‘‰ Description: Errors due to incorrect logic that causes unintended behavior.

       let result = 1 / 0; // No error, but logically incorrect (division by zero)

 </details> 
<details>    
  <summary>6. Runtime Errors</summary>
  
      ðŸ‘‰ Description: Errors that occur during execution, often due to unexpected conditions.

      let obj: any = null;
      console.log(obj.name); // Error: Cannot read property 'name' of null

 </details> 
<details>    
  <summary>7. Module Resolution Errors</summary>
  
      ðŸ‘‰ Description: Occur when TypeScript cannot locate the module you are trying to import.

      import { readFile } from 'fs-extra'; // Error: Cannot find module 'fs-extra'.

 </details> 
<details>    
  <summary>8. Compiler Errors </summary>
  
      ðŸ‘‰ Description: Errors generated by the TypeScript compiler.

      let name = "Alice";
      name = 42; // Error: Type 'number' is not assignable to type 'string'.


 </details> 
<details>    
  <summary>9. Type Assertion Errors </summary>
  
      ðŸ‘‰ Description: Occur when type assertions are incorrectly used.

      let someValue: any = "hello";
      let numValue: number = someValue as number; // No immediate error, but runtime issues may arise

 </details> 
<details>    
  <summary>10. Excess Property Errors </summary>
  
      ðŸ‘‰ Description: Occur when an object literal specifies properties not expected by the assigned type.

      interface User {
       name: string;
        age: number;
      }

     let user: User = { name: "John", age: 30, email: "john@example.com" }; // Error: Object literal may only specify known properties, and 'email' does not exist in type 'User'.

 </details> 
<details>    
  <summary>11. Interface/Type Implementation Errors </summary>
  
      ðŸ‘‰ Description: Errors that occur when a class doesn't correctly implement an interface or type.


      interface Printable {
        print(): void;
      }

      class Document implements Printable {
      // Error: Class 'Document' incorrectly implements interface 'Printable'. Property 'print' is missing.
      }

 </details> 
<details>    
  <summary>12. Function Call Errors </summary>
  
      ðŸ‘‰ Description: Occur when functions are called with incorrect arguments.


      function greet(name: string) {
       console.log(`Hello, ${name}!`);
      }

      greet(); // Error: Expected 1 arguments, but got 0.

 </details> 
<details>    
  <summary>13. Object Property Errors </summary>
  
      ðŸ‘‰ Description: Occur when accessing properties on objects that don't exist or aren't initialized.


      let person = { name: "Alice" };
      console.log(person.age); // Error: Property 'age' does not exist on type '{ name: string; }'.


 </details> 
<details>    
  <summary>14. Enum Errors </summary>
  
      ðŸ‘‰ Description: Occur when using values not defined in an enum.


      enum Color {
       Red,
       Green,
       Blue
      }

      let color: Color = 5; // Error: Type '5' is not assignable to type 'Color'.

 </details> 

<details>    
  <summary>15. Unhandled Promise Rejection Errors </summary>
  
      ðŸ‘‰ Description: Occur when a promise is rejected, and the error isn't handled.


      let promise = new Promise((resolve, reject) => {
      reject("Error!");
      });

      promise.then(() => console.log("Success")); // Error: Unhandled promise rejection.

 </details> 
<details>    
  <summary>16. Assertion and Guard Errors </summary>
  
      ðŸ‘‰ Description: Occur when custom type guards or assertions are used incorrectly.


      function isString(value: any): value is string {
       return typeof value === "string";
      }

    function printLength(value: string | number) {
    if (isString(value)) {
        console.log(value.length);
    } else {
        console.log(value.length); // Error: Property 'length' does not exist on type 'number'.
    }
    }
 </details> 
<details>    
  <summary>17. Optional Property Errors</summary>
  
      ðŸ‘‰ Description: Errors that arise when optional properties arenâ€™t handled correctly.


     interface User {
      name: string;
      age?: number;
     }

    let user: User = { name: "John" };
    console.log(user.age.toFixed(2)); // Error: Object is possibly 'undefined'.

 </details> 
<details>    
  <summary>18. Unreachable Code Errors</summary>
  
      ðŸ‘‰ Description: Occur when TypeScript detects code that will never execute.


        function test(): void {
          return;
         console.log("This will never execute"); // Error: Unreachable code detected.
        }

 </details> 
<details>    
  <summary>19. Circular Dependency Errors</summary>
  
      ðŸ‘‰ Description: Occur when two or more modules depend on each other, creating a loop.


        Example: Module A imports Module B, and Module B imports Module A, leading to a circular dependency error.

 </details> 
<details>    
  <summary>20. Namespace and Scope Errors</summary>
  
      ðŸ‘‰ Description: Occur when there are conflicts or misuse of variables, functions, or classes within different scopes or namespaces.


      namespace MyNamespace {
        export let x = 10;
      }

      let x = 20;
      console.log(MyNamespace.x); // Correct usage
      console.log(x); // Correct usage, but can lead to confusion in larger codebases


 </details> 
<details>    
  <summary>21. Index Signature Errors</summary>
  
      ðŸ‘‰ Description: Occur when using an index signature that doesnâ€™t match the expected type.


     interface Dictionary {
        [key: string]: string;
     }

    let dict: Dictionary = {
    hello: "world",
    count: 42 // Error: Type 'number' is not assignable to type 'string'.
    };
 </details> 
<details>    
  <summary>22. verload Resolution Errors</summary>
  
      ðŸ‘‰ Description: Occur when TypeScript can't determine which overloaded function signature to use.


     function merge(a: string, b: string): string;
     function merge(a: number, b: number): number;
     function merge(a: any, b: any): any {
       return a + b;
     }

    merge("hello", 5); // Error: No overload matches this call.

 </details> 
<details>    
  <summary>23. Null/Undefined Check Errors</summary>
  
      ðŸ‘‰ Description: Occur when you donâ€™t properly handle values that could be `null` or `undefined`.


     let nullableString: string | null = null;
     console.log(nullableString.toUpperCase()); // Error: Object is possibly 'null'.


 </details> 
<details>    
  <summary>24. Union vs. Intersection Type Errors</summary>
  
      ðŸ‘‰ Description: Occur when using union (|) or intersection (&) types incorrectly.


     interface Name {
        firstName: string;
     }

    interface Age {
        age: number;
    }

    type Person = Name | Age;

    const person: Person = {
        firstName: "John",
        age: 25 // Error: Object literal may only specify known properties, and 'firstName' is missing in type 'Age' but    required in type 'Name'.
    };


 </details> 
<details>    
  <summary>25. Ambiguous Call Signature Errors</summary>
  
      ðŸ‘‰ Description: Occur when TypeScript cannot determine which overloaded function signature to use.


     function print(value: string): void;
    function print(value: number): void;
    function print(value: any): void {
        console.log(value);
    }

    print(true); // Error: No overload matches this call.



 </details> 
<details>    
  <summary>26. Tuple Errors</summary>
  
      ðŸ‘‰ Description: Occur when a tuple's length or types are not correctly matched.


     let tuple: [string, number];
    tuple = ["hello", 42, true]; // Error: Tuple type '[string, number]' of length '2

 </details> 
<details>    
  <summary>27. Invalid Type Casting Errors</summary>
  
      ðŸ‘‰ Description: Occur when casting a value to an incorrect or incompatible type.


    let value: any = "123";
    let num: number = <number>value; // Error: Type 'any' cannot be cast to type 'number'.

 </details> 
<details>    
  <summary>28. Non-Null Assertion Errors</summary>
  
      ðŸ‘‰ Description: Occur when using non-null assertions (!) incorrectly.


        function getLength(str?: string) {
          return str!.length; // Error if `str` is undefined.
        }

 </details> 
<details>    
  <summary>29. Destructuring Errors</summary>
  
      ðŸ‘‰ Description: Errors that arise when destructuring an object or array with incorrect or missing properties.


       const { name } = { age: 30 }; // Error: Property 'name' is missing in type '{ age: number; }'.


 </details> 
<details>    
  <summary>30. Type Inference Errors</summary>
  
      ðŸ‘‰ Description: Occur when TypeScript's type inference leads to unexpected or incorrect types.


       let x = 123; // TypeScript infers 'number'
        x = "hello"; // Error: Type 'string' is not assignable to type 'number'.

 </details> 
<details>    
  <summary>31. Discriminated Union Errors</summary>
  
      ðŸ‘‰ Description: Errors related to using discriminated unions when TypeScript cannot narrow down the type correctly.


    interface Dog {
        type: "dog";
        bark(): void;
    }

    interface Cat {
        type: "cat";
        meow(): void;
    }

    type Pet = Dog | Cat;

    function makeSound(pet: Pet) {
        if (pet.type === "dog") {
            pet.bark();
        } else {
        pet.bark(); // Error: Property 'bark' does not exist on type 'Cat'.
        }
    }


 </details> 
<details>    
  <summary>32. Implicit Any Errors</summary>
  
      ðŸ‘‰ Description: Occur when a variable's type is implicitly any, and TypeScript can't infer a more specific type.


      function log(value) { // Error: Parameter 'value'         implicitly     has an 'any' type.
        console.log(value);
      }

 </details> 
<details>    
  <summary>33. Missing Return Type Errors</summary>
  
      ðŸ‘‰ Description: Occur when a function's return type is not explicitly declared and TypeScript cannot infer it correctly.


      function add(a, b) { // Error: Function lacks return type annotation.
        return a + b;
      }


 </details> 
<details>    
  <summary>34. Excessive Recursion Errors</summary>
  
      ðŸ‘‰ Description: Occur when recursion depth is too high, exceeding the call stack limit.


      function recurse() {
        recurse();
        }

    recurse(); // Error: Maximum call stack size exceeded.



 </details> 
<details>    
  <summary>35. Decorator Errors</summary>
  
      ðŸ‘‰ Description: Occur when using decorators incorrectly or with unsupported targets.


     @log
    class MyClass {
        @log
        method() {}
    }

    function log(target: any, propertyKey?: string | symbol) {
        console.log("Decorated", target, propertyKey);
    }


 </details> 
<details>    
  <summary>36. Global vs. Local Scope Errors</summary>
  
      ðŸ‘‰ Description: Errors caused by variable or function name conflicts between global and local scopes.


    let name = "Global";
    function greet() {
        let name = "Local";
        console.log(name); // Logs "Local", which is correct, but   global conflicts can be an issue.
    }



 </details> 
<details>    
  <summary>37. Mixed Array Type Errors</summary>
  
      ðŸ‘‰ Description: Errors when an array is defined with mixed types but is used inappropriately.

        let mixedArray: (string | number)[] = [1, "hello", 3];
        mixedArray.push(true); // Error: Argument of type 'boolean' is  not assignable to parameter of type 'string | number'.


 </details> 
<details>    
  <summary>38. Rest Parameter Errors</summary>
  
      ðŸ‘‰ Description: Occur when using rest parameters incorrectly or in a way that TypeScript cannot infer.

        function sum(...numbers: number[]) {
            return numbers.reduce((a, b) => a + b, 0);
        }

        sum(1, 2, "3"); // Error: Argument of type 'string' is not assignable to parameter of type 'number'.


 </details> 
<details>    
  <summary>39. Spread Operator Errors</summary>
  
      ðŸ‘‰ Description: Occur when using rest parameters incorrectly or in a way that TypeScript cannot infer.

        let arr = [1, 2, 3];
        let arr2 = [...arr, "four"]; // Error: Argument of type 'string' is not assignable to parameter of type 'number'.

 </details> 
<details>    
  <summary>40. Optional Chaining Errors</summary>
  
      ðŸ‘‰ Description: Errors that occur when using optional chaining (?.) incorrectly.

        interface User {
            profile?: {
                name: string;
            };
        }

        const user: User = {};
        console.log(user.profile?.name.length); // Error: Property 'length' does not exist on type 'undefined'.


 </details> 
<details>    
  <summary>41. BigInt Errors</summary>
  
      ðŸ‘‰ Description: Errors when using BigInt in unsupported or incorrect contexts.
       
       let big: bigint = 12345678901234567890n;
    let num: number = big; // Error: Type 'bigint' is not assignable to type 'number'.

 </details> 
<details>    
  <summary>42. Generator Function Errors</summary>
  
      ðŸ‘‰ Description: Errors related to generator functions and their usage.
       
        function* generator() {
            yield* [1, 2, 3];
        }

        let gen = generator();
        console.log(gen.next().value); // Logs 1, which is correct.


 </details> 
<details>    
  <summary>43. Readonly Property Errors</summary>
  
      ðŸ‘‰ Description: Occur when attempting to modify properties marked as readonly.
       
       interface Point {
        readonly x: number;
        readonly y: number;
        }

        let point: Point = { x: 10, y: 20 };
        point.x = 15; // Error: Index signature in type 'Point' only permits reading property 'x'.

 </details> 
<details>    
  <summary>44. Access Modifier Errors (public, private, protected)</summary>
  
      ðŸ‘‰ Description: Errors related to incorrect use of access modifiers.
       
        class Person {
        private name: string;
    
        constructor(name: string) {
                this.name = name;
            }
        }

        let person = new Person("Alice");
        console.log(person.name); // Error: Property 'name' is private and only accessible within class 'Person'.


 </details> 
<details>    
  <summary>45. Abstract Class Implementation Errors</summary>
  
      ðŸ‘‰ Description: Errors that occur when implementing abstract classes incorrectly.

       
        abstract class Animal {
            abstract makeSound(): void;
        }

        class Dog extends Animal {
            // Error: Class 'Dog' incorrectly implements abstract member 'makeSound' in class 'Animal'
        }

 </details> 
<details>    
  <summary>46. Generic Type Errors</summary>
  
      ðŸ‘‰ Description: Errors related to incorrect use of generics.

      function identity<T>(arg: T): T {
            return arg;
      }

    let result = identity<number>("hello"); // Error: Argument of type 'string' is not assignable to parameter of type 'number'.


 </details> 
<details>    
  <summary>47. Custom Type Guard Errors</summary>
  
      ðŸ‘‰ Description: Errors when using custom type guards incorrectly.

      function isString(value: any): value is string {
        return typeof value === "string";
     }

    function printLength(value: string | number) {
        if (isString(value)) {
            console.log(value.length);
        } else {
            console.log(value.length); // Error: Property 'length' does not exist on type 'number'.
        }
    }

 </details> 
<details>    
  <summary>48. Class Property Initialization Errors</summary>
  
      ðŸ‘‰ Description: Errors related to uninitialized properties in classes.

         class MyClass {
            name: string;
    
            constructor() {
            this.name = "default";
             }
         }

         let obj = new MyClass();
         console.log(obj.name); // Correct initialization.


 </details> 
<details>    
  <summary>49. Union Type Narrowing Errors</summary>
  
      ðŸ‘‰ Description: Errors that occur when trying to narrow union types incorrectly.

    function handle(value: string | number) {
       if (typeof value === 'string') {
        console.log(value.toUpperCase()); // Correct
        } else {
        console.log(value.toUpperCase()); // Error: Property 'toUpperCase' does not exist on type 'number'.
       }
    }

 </details> 
<details>    
  <summary>50. Enum Initialization Errors</summary>
  
      ðŸ‘‰ Description: Errors that occur when initializing enum members incorrectly.

    enum Colors {
    Red = "RED",
    Green = "GREEN",
    Blue = "BLUE",
    // Error: Enum member must have initializer if not assigned directly
    }

    let color: Colors = Colors.Red; // Correct usage


 </details> 
<details>    
  <summary>51. Index Signature Errors</summary>
  
      ðŸ‘‰ Description: Errors related to incorrect usage of index signatures in types or interfaces.

    interface Dictionary {
        [key: string]: number;
    }

    let dict: Dictionary = {
        key1: 123,
        key2: "hello" // Error: Type 'string' is not assignable to  type 'number'.
    };

 </details> 
<details>    
  <summary>52. Overload Resolution Errors</summary>
  
      ðŸ‘‰ Description: Errors that occur when TypeScript cannot resolve which overload of a function to use.

        function process(value: string): void;
        function process(value: number): void;
        function process(value: boolean): void;
        function process(value: any): void {
            console.log(value);
        }

        process("string", 123); // Error: No overload matches this call.


 </details> 
<details>    
  <summary>53. Null/Undefined Check Errorss</summary>
  
      ðŸ‘‰ Description: Errors that occur when values that might be null or undefined are accessed without checks.

        function greet(name?: string) {
            console.log(name.toUpperCase()); // Error: Object is        possibly 'undefined'.
        }

 </details> 
<details>    
  <summary>54. Union vs. Intersection Type Errors</summary>
  
      ðŸ‘‰ Description: Errors related to using union (|) and intersection (&) types incorrectly.

        interface Person {
            name: string;
        }

        interface Address {
            street: string;
        }

        let contact: Person & Address = {
            name: "John",
            street: "123 Main St"
        };

        let wrongContact: Person | Address = {
            name: "John" // Error: Property 'street' is missing in type 'Person'.
        };


 </details> 
<details>    
  <summary>55. Ambiguous Call Signature Errors</summary>
  
      ðŸ‘‰ Description: Errors that occur when TypeScript cannot determine which function overload to use.

        function greet(name: string): void;
        function greet(name: string, age: number): void;
        function greet(name: string, age?: number): void {
            console.log(name, age);
        }

        greet("John", "Doe"); // Error: No overload matches this call.


 </details> 
<details>    
  <summary>56. Tuple Errors</summary>
  
      ðŸ‘‰ Description: Errors that occur when working with tuples and their types.

        let tuple: [string, number] = ["hello", 42];
        tuple[2] = "extra"; // Error: Tuple type '[string, number]' of length '2' has no element at index '2'.
        
 </details> 
<details>    
  <summary>57. Invalid Type Casting Errors</summary>
  
      ðŸ‘‰ Description: Errors that occur when casting a type incorrectly.

        let someValue: any = "hello";
        let numValue: number = <number>someValue; // Error: Type 'any'  cannot be cast to type 'number'.


 </details> 
<details>    
  <summary>58. Non-Null Assertion Errors</summary>
  
      ðŸ‘‰ Description: Errors when using non-null assertions incorrectly.

       let value: string | null = null;
        console.log(value!.length); // Error: Object is possibly 'null'.

 </details> 
<details>    
  <summary>59. Destructuring Errors</summary>
  
      ðŸ‘‰ Description: Errors that occur when destructuring an object or array improperly.

       const { x } = { y: 10 }; // Error: Property 'x' does not exist on type '{ y: number; }'.

 </details> 
<details>    
  <summary>60. Type Inference Errors </summary>
  
      ðŸ‘‰ Description: Errors that occur when TypeScript's type inference does not match the expected type.

      let num = 123; // TypeScript infers 'number'
        num = "hello"; // Error: Type 'string' is not assignable to type 'number'.


 </details> 
<details>    
  <summary>61. Discriminated Union Errors </summary>
  
      ðŸ‘‰ Description: Errors when TypeScript cannot narrow down union types correctly using discriminants.

        interface Cat {
            type: "cat";
            meow(): void;
        }

        interface Dog {
            type: "dog";
            bark(): void;
        }

        type Pet = Cat | Dog;

        function makeSound(pet: Pet) {
            if (pet.type === "cat") {
                pet.meow();
            } else {
                pet.bark(); // Error: Property 'bark' does not exist on type 'Cat'.
            }
        }



 </details> 
<details>    
  <summary>62. Excessive Recursion Errors </summary>
  
      ðŸ‘‰ Description: Errors due to deep recursion that exceeds the call stack limit.

        function recurse() {
            recurse();
        }

        recurse(); // Error: Maximum call stack size exceeded.



 </details> 
<details>    
  <summary>63. Decorator Errors</summary>
  
      ðŸ‘‰ Description: Errors related to incorrect usage of decorators.

        @log
        class MyClass {
            @log
            method() {}
        }

        function log(target: any, propertyKey?: string | symbol) {
            console.log("Decorated", target, propertyKey);
        }

 </details> 
<details>    
  <summary>64. Global vs. Local Scope Errors</summary>
  
      ðŸ‘‰ Description: Errors related to scope conflicts between global and local variables.

        let globalVar = "Global";
function test() {
    let localVar = "Local";
    console.log(globalVar); // Correct
    console.log(localVar); // Correct
}


 </details> 
<details>    
  <summary>65. Mixed Array Type Errors</summary>
  
      ðŸ‘‰ Description: Errors that occur when mixing types in an array.

        let mixedArray: (string | number)[] = [1, "hello", 3];
        mixedArray.push(true); // Error: Argument of type 'boolean' is not assignable to parameter of type 'string | number'.



 </details> 
<details>    
  <summary>66. Rest Parameter Errors</summary>
  
      ðŸ‘‰ Description: Errors that occur with rest parameters when their types are not properly handled.

        function sum(...numbers: number[]) {
            return numbers.reduce((a, b) => a + b, 0);
        }

        sum(1, 2, "3"); // Error: Argument of type 'string' is not assignable to parameter of type 'number'.
 </details> 